#! /usr/bin/env python3

from collections import defaultdict
import os, sys, json
import os.path as path
import shutil
from dataclasses import dataclass
from pathlib import Path
import subprocess as process

def get_data_home():
    """
    Gets the xdg data home directory.
    """
    if value := os.getenv("XDG_DATA_HOME"):
        return Path(value)
    return Path.home() / ".local" / "share"

@dataclass
class Person:
    name: str

@dataclass
class Task:
    task_name: str
    score: float

@dataclass
class LevensteinEntry:
    fst: str
    snd: str


    def __hash__(self) -> int:
        return (self.fst, self.snd).__hash__()

    @staticmethod
    def from_tuple(a: str, b: str):
        """
        this ensures correct ordering
        """
        tmp = [a,b]
        tmp.sort()
        return LevensteinEntry(tmp[0], tmp[1])

# Disclosure: This has been generated by an LLM (it was quicker this way D:)
def levenshtein_distance(s1: str, s2: str) -> int:
    len_s1, len_s2 = len(s1), len(s2)
    dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)]
    for i in range(len_s1 + 1):
        for j in range(len_s2 + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
    return dp[len_s1][len_s2]

class Sheet:
    def __init__(self) -> None:
        self.data = {
                # dict of str (person's name) dict of str (task_name) and int (score)
                "name": defaultdict(dict),
                }

    def add_task(self, person: Person, task: Task):
        try:
            self.data["name"][person.name][task.task_name] = task.score
        except KeyError:
            self.data["name"][person.name] = {task.task_name: task.score}

    def person(self, name: str):
        return self.data["name"][name] # TODO make pretty

    def from_file(self, file: Path):
        if not file.exists():
            return self

        with open(file, "r") as io:
            self.data = json.load(io)
        return self
    
    def search(self, key, value) -> list[tuple[str, str]]:
        data = self.data["name"]
        acc = []
        for name, entry in data.items():
            if key in entry:
                content = entry[key]
                f = type(content) # TODO suboptimal
                if value == "" or content == f(value): # compare the strings as otherwise we dont know what we're dealing with
                    acc.append((str(name), str(value)))
        if acc:
            return acc
        return [(f"Can't find any key {key}", str(value))]

    def dups(self, thresh = 2) -> set[LevensteinEntry]:
        """
        @param thresh: int -- The threshold for the returned list
        """
        entries = self.data["name"]
        ret = set()
        for key, _ in entries.items(): # here we would need to split on "_" to ensure we find the correct matches
            for other, _ in entries.items():
                dist = levenshtein_distance(key, other)
                if dist <= thresh and key != other:
                    ret.add(LevensteinEntry.from_tuple(key, other))
        return ret
        
    def get_topics(self) -> set[str]:
        ret = set()
        data = self.data["name"]
        for inner in data.values():
            for x in inner.keys():
                ret.add(x)
        
        return ret

    def to_csv(self) -> str:
        """
        returns the csv of the data
        """
        ret = ""
        entries = self.data["name"]
        # print(json.dumps(entries, indent = 4))

        topics = list(self.get_topics())
        topics.sort()

        ret += "name,matrikel_nummer,"
        ret += ','.join(topics)
        ret += "\n"

        for key, students_topics in entries.items():
            ret += f"{key},,"
            info = [ str(students_topics.get(t, "")) for t in topics ]
            ret += ','.join(info)
            ret += "\n"

        return ret
        

def main():
    data = get_data_home() / "tutoria"
    filepath = data / "sheet.json"
    if not path.exists(data):
        os.makedirs(data)
    
    args = sys.argv[1:]

    if not args or "help" in args:
        print("Please provide a command (one of [ delete | read | names | keys | <name> <topic>:<score> | edit | show with key:value | csv <file_path> | dist | levenstein | dups ])")
        sys.exit(1)

    if len(args) == 1 and args[0] == "edit":
        resolved = process.run(["nvim", filepath.resolve()])
        if resolved.returncode != 0: print("nvim exited not successfully")
        sys.exit(resolved.returncode)

    if len(args) == 1 and args[0] == "delete":
        confirm = input("Are you sure you want to delete the sheet? [type anything to confirm]: ")
        if confirm:
            os.remove(data / "sheet.json")
        else:
            print("Sheet not deleted")
        return

    sheet = Sheet().from_file(filepath)

    if len(args) == 1 and args[0] in ["dist", "levenstein"]:
        print([(a.fst, a.snd) for a in sheet.dups(thresh = 3)])
        return

    if len(args) == 1 and args[0] == "csv":
        print("usage of csv: tutoria csv <file_path>")
        sys.exit(1)

    if len(args) == 2 and args[0] == "csv":
        file = Path(args[1])
        if file.exists():
            print(f"File '{file}' already exists. Aborting.")
            sys.exit(1)

        data = sheet.to_csv()
        with open(file.absolute(), "w") as io:
            io.write(data) 

        return

    if args[0] in ["keys", "names"]:
        sorted_names = sorted(sheet.data["name"].keys(), key = lambda x: x.lower())
        for i, key in enumerate(sorted_names):
            print(f"{i+1}: ", key)
        return

    if "show" in args and "with" in args and len(args) == 3:
        content = args[2].split(":")
        what, value = content[0], ""
        if len(content) == 2:
            value = content[1]
        res = sheet.search(what, value)
        for (key, value) in sorted(res, key = lambda thing: thing[0].lower()):
            print(f"Found '{key}' for '{value}'")
        sys.exit(0)

    if args[0] in [ "read" , "show" ]:
        if len(args) == 2:
            data = sheet.person(args[1])
            max_len = max(len(k) for k in data.keys())
            for k,v in data.items():
                print(f"{k:<{max_len}}: {v}")
        else:
            print(sheet.data)
        return

    topic, score = args[1].split(":")
    sheet.add_task(Person(args[0]), Task(topic, float(score)))

    if path.exists(data / "sheet.json"):
        shutil.copy(data / "sheet.json", data / "sheet.json.bak")

    with open(data / "sheet.json", "w") as io:
        json.dump(sheet.data, io, indent=4)

if __name__ == '__main__':
    main() 

